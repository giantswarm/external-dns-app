# Default values for external-dns-chart.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# aws
# Configuration options specific to external-dns when running in AWS
# clusters.
aws:

  # aws.access
  # Route53 access type. Use 'internal' to utilise in-cluster AWS authentication
  # via KIAM, or 'external' to access the AWS API via the public endpoints. When
  # using external access, you must also provide the AWS access credentials below.
  # Note that external access can only update public hosted zones, whereas internal
  # can update public and private zones.
  access: internal

  # aws.accountID
  # AWS account ID is used to assume role via IRSA (IAM roles for service accounts).
  # It is dynamically set and will be overridden.
  accountID: ""

  # aws.baseDomain
  # If aws.access is 'external' then the domain to update must be set.
  baseDomain:

  # aws.batchChangeSize
  # Maximum number of changes applied in each batch. If left blank then the
  # default will be used.
  batchChangeSize:

  # aws.batchChangeInterval
  # Set interval between batch changes. If left blank then the default will
  # be used.
  batchChangeInterval: 10s

  # aws.irsa
  # Set to true when IAM roles for service accounts is enabled.
  # It is dynamically set and will be overridden.
  irsa: "false"

  # aws.zonesCacheDuration
  # Set the zones list cache TTL. If left blank then the default will
  # be used.
  zonesCacheDuration: 3h

  # aws.iam
  # AWS IAM configuration.
  iam:

    # aws.iam.customRole
    # If set, allows a user-created role to be assumed. Role must have access to a
    # policy which allows configuration of Route53 hosted zone(s).
    # e.g. `customRoleName: route53-manager-role`
    customRoleName:

  # aws.preferCNAME
  # Create CNAME records instead of ALIAS. Will always be set to true when aws.access
  # is `external`.
  preferCNAME: false

  # aws.region
  # If aws.access is 'external' then the AWS region must be set.
  region:

  # aws.zoneType
  # Filters hosted zones to update based on type. Supported options: `public`,
  # `private`. Leave blank to not filter based on zone type. If `aws.access` is
  # set to `external` then the zone type is automatically set to `public` and
  # cannot be changed.
  zoneType:

# gcpProject
# The GCP project in which external-dns will create records.
gcpProject: ""

# externalDNS
# Configuration options for external-dns itself.
externalDNS:

  # externalDNS.annotationFilter
  # Annotation to filter objects to reconcile. Use in conjunction with
  # `externalDNS.sources` to limit further. This must be provided when running multiple
  # instances of external-dns.
  annotationFilter: "giantswarm.io/external-dns=managed"

  # externalDNS.aws_access_key_id
  # Access key ID for the AWS API. Only required when aws.access is 'external'.
  aws_access_key_id:

  # externalDNS.aws_secret_access_key
  # Access key secret for the AWS API. Only required when aws.access is 'external'.
  aws_secret_access_key:

  # externalDNS.domainFilterList
  # One or more domains that this instance of external-dns will manage. If
  # no domains are provided then the cluster baseDomain must be provided via
  # either `baseDomain` or `aws.baseDomain` (depending on the Route53 access
  # method used).
  # By explicitly setting externalDNS.domainFilterList to null, the --domain-filter
  # flag will be completely omitted. Otherwise leave this as empty array ([])
  domainFilterList: []
  # - foo.bar.com
  # - baz.bar.com

  # externalDNS.namespaceFilter
  # The namespace to limit sources of endpoints to. If left blank, all
  # namespaces will be used.
  namespaceFilter: kube-system

  # externalDNS.registry
  # Configuration options relating to ownership of created records.
  registry:

    # externalDNS.registry.txtOwnerID
    # String to identify this instance of external-dns and the records it owns. See
    # https://github.com/kubernetes-sigs/external-dns/blob/master/docs/proposal/registry.md
    txtOwnerID: managed-external-dns

    # externalDNS.registry.txtPrefix
    # String prefix applied to TXT registry records. See
    # https://github.com/kubernetes-sigs/external-dns/blob/master/docs/proposal/registry.md
    txtPrefix: extdns

# set the HTTP_PROXY, HTTPS_PROXY and NO_PROXY variable
proxy:
  noProxy:
  http:
  https:
cluster:
  # is getting overwritten by the top level proxy if set
  # These values are generated via cluster-apps-operator
  proxy:
    noProxy:
    http:
    https:

# crd
# Configuration options for CRDs.
crd:

  # crd.backoffLimit
  # setting this higher means the CRD creation is less likely to be marked
  # as failed.
  backoffLimit: 10

  # crd.image
  image:

    # crd.image.pullPolicy
    pullPolicy: IfNotPresent

  # crd.install
  # CRDs are installed by default. If this is disabled then CRDs must
  # be managed by another method.
  install: true

  # crd.resources
  resources:

    # crd.resources.requests
    # Minimum resources requested for the job.
    requests:
      cpu: 100m
      memory: 256Mi

    # crd.resources.limits
    # Maximum resources available for the job.
    limits:
      cpu: 500m
      memory: 512Mi

  podSecurityContext:
    runAsGroup: 65534
    runAsUser: 65534
    seccompProfile:
      type: RuntimeDefault

image:
  name: giantswarm/external-dns
  registry: docker.io
  tag: v0.11.0
  pullPolicy: IfNotPresent

imagePullSecrets: []

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # Labels to add to the service account
  labels: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

rbac:
  # Specifies whether RBAC resources should be created
  create: true
  additionalPermissions: []

# Annotations to add to the Deployment
deploymentAnnotations: {}

podLabels: {}

# Annotations to add to the Pod
podAnnotations:
  cluster-autoscaler.kubernetes.io/safe-to-evict: "true"
  kubectl.kubernetes.io/default-container: external-dns

shareProcessNamespace: false

podSecurityContext:
  fsGroup: 65534
  runAsGroup: 65534
  runAsUser: 65534
  seccompProfile:
    type: RuntimeDefault

securityContext:
  allowPrivilegeEscalation: false
  runAsNonRoot: true
  runAsUser: 65534
  readOnlyRootFilesystem: true
  capabilities:
    drop: ["ALL"]

# Defaults to `ClusterFirst`.
# Valid values are: `ClusterFirstWithHostNet`, `ClusterFirst`, `Default` or `None`.
dnsPolicy:

priorityClassName: "giantswarm-critical"

serviceMonitor:
  enabled: true
  # force namespace
  # namespace: monitoring

  # Fallback to the prometheus default unless specified
  interval: 60s

  ## scheme: HTTP scheme to use for scraping. Can be used with `tlsConfig` for example if using istio mTLS.
  # scheme: ""

  ## tlsConfig: TLS configuration to use when scraping the endpoint. For example if using istio mTLS.
  ## Of type: https://github.com/coreos/prometheus-operator/blob/master/Documentation/api.md#tlsconfig
  # tlsConfig: {}

  # bearerTokenFile:
  # Fallback to the prometheus default unless specified
  # scrapeTimeout: 30s

  ## Used to pass Labels that are used by the Prometheus installed in your cluster to select Service Monitors to work with
  ## ref: https://github.com/coreos/prometheus-operator/blob/master/Documentation/api.md#prometheusspec
  additionalLabels: {}

  ## Used to pass annotations that are used by the Prometheus installed in your cluster to select Service Monitors to work with
  ## ref: https://github.com/coreos/prometheus-operator/blob/master/Documentation/api.md#prometheusspec
  annotations: {}

  ## Metric relabel configs to apply to samples before ingestion.
  ## [Metric Relabeling](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs)
  metricRelabelings: []
  # - action: keep
  #   regex: 'kube_(daemonset|deployment|pod|namespace|node|statefulset).+'
  #   sourceLabels: [__name__]

  ## Relabel configs to apply to samples before ingestion.
  ## [Relabeling](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config)
  relabelings:
    - action: replace
      regex: ;(.*)
      replacement: $1
      separator: ;
      sourceLabels:
      - namespace
      - __meta_kubernetes_namespace
      targetLabel: namespace
    - action: replace
      sourceLabels:
      - __meta_kubernetes_pod_label_app
      targetLabel: app
    - action: replace
      sourceLabels:
      - __meta_kubernetes_pod_node_name
      targetLabel: node
  targetLabels: []

env: []

livenessProbe:
  httpGet:
    path: /healthz
    port: http
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 2
  successThreshold: 1

readinessProbe:
  httpGet:
    path: /healthz
    port: http
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 6
  successThreshold: 1

service:
  port: 7979
  annotations: {}

extraVolumes: []

extraVolumeMounts: []

tolerations: []

resources:
  limits:
    memory: 100Mi
  requests:
    cpu: 50m
    memory: 100Mi

nodeSelector: {}

affinity: {}

topologySpreadConstraints: []

logLevel: info
logFormat: text

interval: 5m
triggerLoopOnEvent: false

terminationGracePeriodSeconds:

sources:
  - service

policy: sync

# provider
# Identifies the cloud provider. Currently supported: `aws` and `azure`. This *must*
# be set. If this is installed as a default app from the default-catalog then this
# value is set dynamically and will be overridden.
provider: CHANGEME

extraArgs: []

secretConfiguration:
  enabled: false
  mountPath: /.aws/credentials
  subPath: ""
  data: {}

deploymentStrategy:
  type: Recreate

# hostNetwork
hostNetwork: false

## Do not change any values below; these are specific to Giant Swarm environments.

# serviceType:
# Resources will be annotated with this value. Specific to Giant Swarm clusters.
serviceType: "managed"

# e2e
# Is the app running in CI.
e2e: false

# baseDomain
# The base domain of the cluster. This is only used if this chart is installed as
# a default app from the default-catalog. It is dynamically set and will be
# overridden. Specific to Giant Swarm clusters.
baseDomain: gigantic.io

# clusterID
# The cluster's ID. This is only used if this chart is installed as a default app
# from the default-catalog. It is dynamically set and will be overridden. Specific
# to Giant Swarm clusters.
clusterID: en2jo

ciliumNetworkPolicy:
  enabled: false
